var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GaussianExpansionCavityMethod","category":"page"},{"location":"#GaussianExpansionCavityMethod","page":"Home","title":"GaussianExpansionCavityMethod","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GaussianExpansionCavityMethod.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GaussianExpansionCavityMethod]","category":"page"},{"location":"#GaussianExpansionCavityMethod.BMModel","page":"Home","title":"GaussianExpansionCavityMethod.BMModel","text":"BMModel\n\nA type representing the Bouchaud-Mezard model.\n\nFields\n\nN::Integer: The number of sites.\nK::Union{Integer, Float64}: The average number of neighbors.\nlambdas::Vector{Float64}: The local drift terms. lambdas[i] = J |∂i|, where |∂i| is the degree of site i and J is the uniform coupling strength.\nJ::SparseMatrixCSC{Float64, Integer}: The sparse coupling matrix.\nsigma::Float64: The multiplicative noise strength.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.BMModelEnsemble","page":"Home","title":"GaussianExpansionCavityMethod.BMModelEnsemble","text":"BMModelEnsemble\n\nA type representing the ensemble of disordered Bouchaud-Mezard model.\n\nFields\n\nN::Integer: The number of sites.\nK::Union{Integer, Float64}: The average number of neighbors.\nlambdas::Vector{Float64}: The local drift terms. lambdas[i] = J |∂i|, where |∂i| is the degree of site i and J is the uniform coupling strength.\ngen_J::Function: The function to generate the sparse coupling matrix.\nJ_params::Vector{Float64}: The parameters for the coupling matrix generator.\nsigma::Float64: The multiplicative noise strength.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.Cavity","page":"Home","title":"GaussianExpansionCavityMethod.Cavity","text":"Cavity\n\nA structure representing a cavity in a graph with its associated parameters.\n\nFields\n\ni::Int: The index of the node.\nj::Int: The index of the neighbor.\nmu::OffsetVector{Float64, Vector{Float64}}: The mean vector.\nC::OffsetMatrix{Float64, Matrix{Float64}}: The autocorellation matrix.\nR::OffsetMatrix{Float64, Matrix{Float64}}: The response matrix.\n\nDescription\n\nThe Cavity structure represents a cavity in a graph, which is a subgraph formed by removing a node and its associated edges. Each cavity has an index i, a neighbor index j, and associated cavity fields such as the mean vector mu, the autocorrelation matrix C, and the response matrix R.\n\nMethods\n\nCavity(i::Int, j::Int, T::Int): Constructs a cavity with index i, neighbor index j, and T timesteps.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.CavityEQ","page":"Home","title":"GaussianExpansionCavityMethod.CavityEQ","text":"CavityEQ\n\nA structure representing a equilibrium cavity in a graph with its associated parameters.\n\nFields\n\ni::Int: The index of the node.\nj::Int: The index of the neighbor.\nC::OffsetVector{Float64, Vector{Float64}}: The autocorellation vector.\n\nDescription\n\nThe CavityEQ structure represents a equilibrium cavity in a graph, which is a subgraph formed by removing a node and its associated edges. Each cavity has an index i, a neighbor index j, and associated cavity field such as the autocorrelation vector C.\n\nMethods\n\nCavityEQ(i::Int, j::Int, T::Int): Constructs a equilibrium cavity with index i, neighbor index j, and T timesteps.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.Marginal","page":"Home","title":"GaussianExpansionCavityMethod.Marginal","text":"Marginal\n\nA structure representing a marginal in a graph with its associated parameters.\n\nFields\n\ni::Int: The index of the node.\nmu::OffsetVector{Float64, Vector{Float64}}: The mean vector.\nC::OffsetMatrix{Float64, Matrix{Float64}}: The autocorellation matrix.\nR::OffsetMatrix{Float64, Matrix{Float64}}: The response matrix.\n\nDescription\n\nThe Marginal structure represents a marginal in a graph, which is a subgraph formed by removing a node and its associated edges. Each marginal has an index i, and associated marginal fields such as the mean vector mu, the autocorrelation matrix C, and the response matrix R.\n\nMethods\n\nMarginal(i::Int, T::Int): Constructs a marginal with index i and T timesteps.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.MarginalEQ","page":"Home","title":"GaussianExpansionCavityMethod.MarginalEQ","text":"MarginalEQ\n\nA structure representing a equilibrium marginal in a graph with its associated parameters.\n\nFields\n\ni::Int: The index of the node.\nmu::Float64: The mean at infinity.\nC::OffsetVector{Float64, Vector{Float64}}: The autocorellation vector.\nR::OffsetVector{Float64, Vector{Float64}}: The response vector.\n\nDescription\n\nThe MarginalEQ structure represents a equilibrium marginal in a graph, which is a subgraph formed by removing a node and its associated edges. Each marginal has an index i, and associated marginal fields such as the mean at infinity mu, the autocorrelation vector C, and the response vector R.\n\nMethods\n\nMarginalEQ(i::Int, T::Int): Constructs an equilibrium marginal with index i and T timesteps.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.Node","page":"Home","title":"GaussianExpansionCavityMethod.Node","text":"Node\n\nA structure representing a node in a graph with its neighbors and associated cavities and marginal.\n\nFields\n\ni::Int: The index of the node.\nneighs::Vector{Int}: The indices of the neighbors.\ncavs::Vector{Cavity}: The cavities associated with the node.\nmarg::Marginal: The marginal associated with the node.\n\nDescription\n\nThe Node structure represents a node in a graph, along with its neighbors and associated cavities and marginal. Each node has an index i, a vector of neighbor indices neighs, a vector of cavities cavs and a marginal marg.\n\nMethods\n\nNode(i::Int, neighs::Vector{Int}, T::Int): Constructs a node with index i, neighbors neighs, and T timesteps.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.NodeEQ","page":"Home","title":"GaussianExpansionCavityMethod.NodeEQ","text":"NodeEQ\n\nA structure representing a equilibrium node in a graph with its neighbors and associated cavities and marginal.\n\nFields\n\ni::Int: The index of the node.\nneighs::Vector{Int}: The indices of the neighbors.\nneighs_idxs::Dict{Int, Int}: A dictionary mapping neighbor indices to their positions in the neighs vector.\ncavs::Vector{CavityEQ}: The equilibrium cavities associated with the node.\nmarg::MarginalEQ: The equilibrium marginal associated with the node.\nsumC::OffsetVector{Float64, Vector{Float64}}: Internal variable.\nsumdiffC::OffsetVector{Float64, Vector{Float64}}: Internal variable.\n\nDescription\n\nThe NodeEQ structure represents a equilibrium node in a graph, along with its neighbors and associated equilibrium cavities and marginal. Each node has an index i, a vector of neighbor indices neighs, a vector of equilibrium cavities cavs and a equilibrium marginal marg.\n\nMethods\n\nNodeEQ(i::Int, neighs::Vector{Int}, T::Int): Constructs a node with index i, neighbors neighs, and T timesteps.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.OUModel","page":"Home","title":"GaussianExpansionCavityMethod.OUModel","text":"OUModel\n\nA structure representing a linearly-coupled Ornstein-Uhlenbeck model with its associated parameters.\n\nFields\n\nN::Int: The number of nodes in the model.\nK::Union{Int, Float64}: The average number of neighbors.\nJ::SparseMatrixCSC{Float64, Int}: The coupling matrix.\nlambdas::Vector{Float64}: The local decay rates.\nD::Float64: The diffusion coefficient.\n\nDescription\n\nThe OUModel structure represents a linearly-coupled Ornstein-Uhlenbeck model, which is a stochastic process used to model the dynamics of a system with local decay rates and coupling between nodes. Each model has a number of nodes N, local decay rates lambdas, a coupling matrix J, and a diffusion coefficient D.\n\nMethods\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.OUModelEnsemble","page":"Home","title":"GaussianExpansionCavityMethod.OUModelEnsemble","text":"OUModelEnsemble\n\nA type representing the ensemble of disordered Ornstein-Uhlenbeck model.\n\nFields\n\nN::Integer: The number of sites.\nK::Union{Integer, Float64}: The average number of neighbors.\ngen_J::Function: The function to generate the sparse coupling matrix.\nJ_params::Vector{Float64}: The parameters for the coupling matrix generator.\nlambdas::Vector{Float64}: The local decay rates.\nD::Float64: The diffusion coefficient.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.Phi4Model","page":"Home","title":"GaussianExpansionCavityMethod.Phi4Model","text":"Phi4Model\n\nA type representing the Phi^4 model.\n\nFields\n\nN::Integer: The number of sites.\nK::Union{Integer, Float64}: The average number of neighbors.\nJ::SparseMatrixCSC{Float64, Integer}: The sparse coupling matrix.\nlambdas::Vector{Float64}: The on-site linear terms.\nD::Float64: The noise strength.\nu::Float64: The cubic perturbative constant.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.Phi4ModelEnsemble","page":"Home","title":"GaussianExpansionCavityMethod.Phi4ModelEnsemble","text":"Phi4ModelEnsemble\n\nA type representing the ensemble of disordered Phi^4 model.\n\nFields\n\nN::Integer: The number of sites.\nK::Union{Integer, Float64}: The average number of neighbors.\ngen_J::Function: The function to generate the sparse coupling matrix.\nJ_params::Vector{Float64}: The parameters for the coupling matrix generator.\nlambdas::Vector{Float64}: The on-site linear terms.\nD::Float64: The noise strength.\nu::Float64: The cubic perturbative constant.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.TwoSpinModel","page":"Home","title":"GaussianExpansionCavityMethod.TwoSpinModel","text":"TwoSpinModel\n\nA type representing the spherical 2-Spin model.\n\nFields\n\nN::Integer: The number of sites.\nK::Union{Integer, Float64}: The average number of neighbors.\nJ::SparseMatrixCSC{Float64, Integer}: The sparse coupling matrix.\nD::Float64: The noise strength.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.TwoSpinModelEnsemble","page":"Home","title":"GaussianExpansionCavityMethod.TwoSpinModelEnsemble","text":"TwoSpinModelEnsemble\n\nA type representing the ensemble of disordered spherical 2-Spin model.\n\nFields\n\nN::Integer: The number of sites.\nK::Union{Integer, Float64}: The average number of neighbors.\ngen_J::Function: The function to generate the sparse coupling matrix.\nJ_params::Vector{Float64}: The parameters for the coupling matrix generator.\nD::Float64: The noise strength.\n\n\n\n\n\n","category":"type"},{"location":"#GaussianExpansionCavityMethod.BMModelRRG-Tuple{Int64, Union{Float64, Int64}, Float64, Float64}","page":"Home","title":"GaussianExpansionCavityMethod.BMModelRRG","text":"BMModelRRG(N, K, J, sigma)\n\nConstruct a Bouchaud-Mezard model with a random regular graph coupling matrix with ferromagnetic interactions.\n\nArguments\n\nN::Integer: The number of sites.\nK::Union{Int, Float64}: The average number of neighbors.\nJ::Float64: The coupling strength.\nsigma::Float64: The multiplicative noise strength.\n\nReturns\n\nBMModelEnsemble: The Bouchaud-Mezard model.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.OUModelRRG-Tuple{Int64, Union{Float64, Int64}, Float64, Vector{Float64}, Float64, Float64, Float64}","page":"Home","title":"GaussianExpansionCavityMethod.OUModelRRG","text":"OUModelRRG(N, K, J, lambdas, D, x0_min, x0_max)\n\nConstruct a Ornstein-Uhlenbeck model with a random regular graph coupling matrix with ferromagnetic interactions.\n\nArguments\n\nN::Integer: The number of sites.\nK::Union{Int, Float64}: The average number of neighbors.\nJ::Float64: The coupling strength.\nlambdas::Vector{Float64}: The local decay rates.\nD::Float64: The diffusion coefficient.\nx0_min::Float64: The minimum initial condition.\nx0_max::Float64: The maximum initial condition.\n\nReturns\n\nOUModelEnsemble: The Ornstein-Uhlenbeck model.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.OUModelRRG-Tuple{Int64, Union{Float64, Int64}, Vararg{Float64, 5}}","page":"Home","title":"GaussianExpansionCavityMethod.OUModelRRG","text":"OUModelRRG(N, K, J, lambda, D, x0_min, x0_max)\n\nConstruct a Ornstein-Uhlenbeck model with a random regular graph coupling matrix with ferromagnetic interactions.\n\nArguments\n\nN::Integer: The number of sites.\nK::Union{Int, Float64}: The average number of neighbors.\nJ::Float64: The coupling strength.\nlambda::Float64: The uniform local decay rates.\nD::Float64: The diffusion coefficient.\nx0_min::Float64: The minimum initial condition.\nx0_max::Float64: The maximum initial condition.\n\nReturns\n\nOUModelEnsemble: The Ornstein-Uhlenbeck model.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.Phi4ModelRRG-Tuple{Int64, Union{Float64, Int64}, Float64, Vector{Float64}, Float64, Float64}","page":"Home","title":"GaussianExpansionCavityMethod.Phi4ModelRRG","text":"Phi4ModelRRG(N, K, J, lambdas, D, u)\n\nConstruct a Phi^4 model with a random regular graph coupling matrix with ferromagnetic interactions.\n\nArguments\n\nN::Integer: The number of sites.\nK::Union{Int, Float64}: The average number of neighbors.\nJ::Float64: The coupling strength.\nlambdas::Vector{Float64}: The on-site linear terms.\nD::Float64: The noise strength.\nu::Float64: The cubic perturbative constant.\n\nReturns\n\nPhi4ModelEnsemble: The Phi^4 model.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.Phi4ModelRRG-Tuple{Int64, Union{Float64, Int64}, Vararg{Float64, 4}}","page":"Home","title":"GaussianExpansionCavityMethod.Phi4ModelRRG","text":"Phi4ModelRRG(N, K, J, lambda, D, u)\n\nConstruct a Phi^4 model with a random regular graph coupling matrix with ferromagnetic interactions.\n\nArguments\n\nN::Integer: The number of sites.\nK::Union{Int, Float64}: The average number of neighbors.\nJ::Float64: The coupling strength.\nlambda::Float64: The on-site linear term.\nD::Float64: The noise strength.\nu::Float64: The cubic perturbative constant.\n\nReturns\n\nPhi4ModelEnsemble: The Phi^4 model.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.TwoSpinModelRRG-Tuple{Int64, Union{Float64, Int64}, Float64, Float64}","page":"Home","title":"GaussianExpansionCavityMethod.TwoSpinModelRRG","text":"TwoSpinModelRRG(N, K, J, lambda, D)\n\nConstruct a spherical 2-Spin model with a random regular graph coupling matrix with bimodal interactions.\n\nArguments\n\nN::Integer: The number of sites.\nK::Union{Int, Float64}: The average number of neighbors.\nJ::Float64: The coupling strength.\nD::Float64: The noise strength.\n\nReturns\n\nTwoSpinModelEnsemble: The spherical 2-Spin  model.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.TwoSpinModelRRG-Tuple{Int64, Union{Float64, Int64}, Function, Vector{Float64}, Float64}","page":"Home","title":"GaussianExpansionCavityMethod.TwoSpinModelRRG","text":"TwoSpinModelRRG(N, K, J, lambda, D)\n\nConstruct a spherical 2-Spin model with a random regular graph coupling matrix with iid symmetric couplings Jᵢⱼ = Jⱼᵢ ~ p(J).\n\nArguments\n\nN::Integer: The number of sites.\nK::Union{Int, Float64}: The average number of neighbors.\npJ::Function: The coupling distribution.\nJ_params::Vector{Float64}: The parameters for the coupling distribution.\nD::Float64: The noise strength.\n\nReturns\n\nTwoSpinModelEnsemble: The spherical 2-Spin  model.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.compute_autocorr-Tuple{Matrix{Float64}}","page":"Home","title":"GaussianExpansionCavityMethod.compute_autocorr","text":"compute_autocorr(trajs; time_indices=nothing)\n\nCompute the average autocorrelation of the trajectories.\n\nArguments\n\ntrajs::Matrix{Float64}: The trajectories. Each column corresponds to a time point.\n\nKeyword Arguments\n\ntime_indices::Union{Nothing, AbstractVector{Int}}: The time indices to compute the autocorrelation. If nothing, all time indices are used.\n\nReturns\n\nautocorr::Matrix{Float64}: The average autocorrelation. The element at index (l, k) is the average autocorrelation of the trajectories at discretized times l and k.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.compute_autocorr-Tuple{Vector{Matrix{Float64}}}","page":"Home","title":"GaussianExpansionCavityMethod.compute_autocorr","text":"compute_autocorr(sim; time_indices=nothing)\n\nCompute the average autocorrelation of the trajectories in the ensemble solution object.\n\nArguments\n\nsim::Vector{Matrix{Float64}}: The ensemble solution object. Each element is a matrix where each column corresponds to a time point.\n\nKeyword Arguments\n\ntime_indices::Union{Nothing, AbstractVector{Int}}: The time indices to compute the autocorrelation. If nothing, all time indices are used.\n\nReturns\n\nautocorr::Matrix{Float64}: The average autocorrelation. The element at index (l, k) is the average autocorrelation of the trajectories over nodes and ensemble realizations at discretized times l and k.\nt_idx::Vector{Int}: The time indices used to compute the autocorrelation.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.compute_autocorr_TTI-Tuple{Matrix{Float64}, Int64}","page":"Home","title":"GaussianExpansionCavityMethod.compute_autocorr_TTI","text":"compute_autocorr_TTI(trajs, teq; lag_indices=nothing)\n\nCompute the average autocorrelation of the trajectories in the stationary phase, i.e. after the transient time teq. It assumes that after the transient time, the trajectories are stationary, therefore the autocorrelation is time tranlational invariant (TTI), i.e. it only depends on the time differences C(t,t') = C(t-t').\n\nArguments\n\ntrajs::Matrix{Float64}: The trajectories. Each column corresponds to a time point.\nteq::Int: The transient time.\n\nKeyword Arguments\n\nlag_indices::Union{Nothing, AbstractVector{Int}}: The lag indices to compute the autocorrelation. If nothing, all lag indices are used.\n\nReturns\n\nautocorr::Vector{Float64}: The average TTI autocorrelation. The element at index l is the average autocorrelation of the trajectories at discretized time difference l.\nerr_autocorr::Vector{Float64}: The error associated to the TTI autocorrelation. The element at index l is error of the average autocorrelation of the trajectories at discretized time difference l.\nl_idx::Vector{Int}: The lag indices used to compute the autocorrelation.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.compute_autocorr_TTI-Tuple{Vector{Matrix{Float64}}, Int64}","page":"Home","title":"GaussianExpansionCavityMethod.compute_autocorr_TTI","text":"compute_autocorr_TTI(sim, teq; lag_indices=nothing)\n\nCompute the average autocorrelation of the trajectories in the ensemble solution object in the stationary phase, i.e. after the transient time teq. It assumes that after the transient time, the trajectories are stationary, therefore the autocorrelation is time tranlational invariant (TTI), i.e. it only depends on the time differences C(t,t') = C(t-t').\n\nArguments\n\nsim::Vector{Matrix{Float64}}: The ensemble solution object. Each element is a matrix where each column corresponds to a time point.\nteq::Int: The transient time.\n\nKeyword Arguments\n\nlag_indices::Union{Nothing, AbstractVector{Int}}: The lag indices to compute the autocorrelation. If nothing, all lag indices are used.\n\nReturns\n\nautocorr::Vector{Float64}: The average TTI autocorrelation. The element at index l is the average autocorrelation of the trajectories over nodes and ensemble realizations at discretized time difference l.\nerr_autocorr::Vector{Float64}: The error associated to the TTI autocorrelation. The element at index l is error of the average autocorrelation of the trajectories over nodes and ensemble realizations at discretized time difference l.\nl_idx::Vector{Int}: The lag indices used to compute the autocorrelation.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.compute_averages-Tuple{Vector{NodeEQ}, OUModel, Int64}","page":"Home","title":"GaussianExpansionCavityMethod.compute_averages","text":"compute_averages(nodes, model, T)\n\nCompute the equilibrium averages over nodes of the corrlation and response functions.\n\nArguments\n\nnodes::Vector{NodeEQ}: The nodes containing the cavity autocorrelations and the marginal fields.\nmodel::OUModel: The Ornstein-Uhlenbeck model.\nT::Int: The number of time steps.\n\nReturns\n\nC_avg::OffsetVector{Float64, Vector{Float64}}: The average correlation function over the nodes.\nR_avg::OffsetVector{Float64, Vector{Float64}}: The average response function over the nodes.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.compute_meanstd-Tuple{Matrix{Float64}}","page":"Home","title":"GaussianExpansionCavityMethod.compute_meanstd","text":"compute_meanstd(trajs; time_indices=nothing)\n\nCompute the mean and standard deviation of the trajectories.\n\narguments\n\ntrajs::Matrix{Float64}: The trajectories. Each column corresponds to a time point.\n\nKeyword Arguments\n\ntime_indices::Union{Nothing, AbstractVector{Int}}: The time indices to compute the mean and standard deviation. If nothing, all time indices are used.\n\nReturns\n\nmean_traj::Vector{Float64}: The mean trajectory. The element at index l is the mean of the trajectories at discretized time l`.\nstd_traj::Vector{Float64}: The standard deviation trajectory. The element at index l is the standard deviation of the trajectories at discretized time l.\nt_idx::Vector{Int}: The time indices used to compute the mean and standard deviation.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.compute_meanstd-Tuple{Vector{Matrix{Float64}}}","page":"Home","title":"GaussianExpansionCavityMethod.compute_meanstd","text":"compute_meanstd(sim; time_indices=nothing)\n\nCompute the mean and standard deviation of the trajectories in the ensemble solution object.\n\nArguments\n\nsim::Vector{Matrix{Float64}}: The ensemble solution object. Each element is a matrix where each column corresponds to a time point.\n\nKeyword Arguments\n\ntime_indices::Union{Nothing, AbstractVector{Int}}: The time indices to compute the mean and standard deviation. If nothing, all time indices are used.\n\nReturns\n\nmean_traj::Vector{Float64}: The mean trajectory. The element at index l is the mean of the trajectories over nodes and ensemble realizations at discretized time l.\nstd_traj::Vector{Float64}: The standard deviation trajectory. The element at index l is the standard deviation of the trajectories over nodes and ensemble realizations at discretized time l.\nt_idx::Vector{Int}: The time indices used to compute the mean and standard deviation.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.compute_stats-Tuple{Matrix{Float64}}","page":"Home","title":"GaussianExpansionCavityMethod.compute_stats","text":"compute_stats(trajs)\n\nCompute the mean, standard deviation and average autocorrelation of the trajectories.\n\nArguments\n\ntrajs::Matrix{Float64}: The trajectories. Each column corresponds to a time point.\n\nReturns\n\nmean_traj::Vector{Float64}: The mean trajectory. The element at index l is the mean of the trajectories at discretized time l.\nstd_traj::Vector{Float64}: The standard deviation trajectory. The element at index l is the standard deviation of the trajectories at discretized time l.\nautocorr::Matrix{Float64}: The average autocorrelation. The element at index (l, k) is the average autocorrelation of the trajectories at discretized times l and k.\nt_idx::Vector{Int}: The time indices used to compute the mean and standard deviation.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.compute_stats-Tuple{Vector{Matrix{Float64}}}","page":"Home","title":"GaussianExpansionCavityMethod.compute_stats","text":"compute_stats(sim; time_indices=nothing)\n\nCompute the mean, standard deviation and average autocorrelation of the trajectories in the ensemble solution object.\n\nArguments\n\nsim::Vector{Matrix{Float64}}: The ensemble solution object. Each element is a matrix where each column corresponds to a time point.\n\nKeyword Arguments\n\ntime_indices::Union{Nothing, AbstractVector{Int}}: The time indices to compute the mean and standard deviation. If nothing, all time indices are used.\n\nReturns\n\nmean_traj::Vector{Float64}: The mean trajectory. The element at index l is the mean of the trajectories over nodes and ensemble realizations at discretized time l.\nstd_traj::Vector{Float64}: The standard deviation trajectory. The element at index l is the standard deviation of the trajectories over nodes and ensemble realizations at discretized time l.\nautocorr::Matrix{Float64}: The average autocorrelation. The element at index (l, k) is the average autocorrelation of the trajectories over nodes and ensemble realizations at discretized times l and k.\nt_idx::Vector{Int}: The time indices used to compute the mean and standard deviation.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.compute_stats_TTI-Tuple{Matrix{Float64}, Int64}","page":"Home","title":"GaussianExpansionCavityMethod.compute_stats_TTI","text":"compute_stats_TTI(trajs, teq; time_indices=nothing, lag_indices=nothing)\n\nCompute the mean, standard deviation and average autocorrelation of the trajectories in the stationary phase, i.e. after the transient time teq. It assumes that after the transient time, the trajectories are stationary, therefore the autocorrelation is time tranlational invariant (TTI), i.e. it only depends on the time differences C(t,t') = C(t-t').\n\nArguments\n\ntrajs::Matrix{Float64}: The trajectories. Each column corresponds to a time point.\nteq::Int: The transient time.\n\nKeyword Arguments\n\ntime_indices::Union{Nothing, AbstractVector{Int}}: The time indices to compute the mean and standard deviation. If nothing, all time indices are used.\nlag_indices::Union{Nothing, AbstractVector{Int}}: The lag indices to compute the autocorrelation. If nothing, all lag indices are used.\n\nReturns\n\nmean_traj::Vector{Float64}: The mean TTI trajectory. The element at index l is the mean of the trajectories at discretized time l.\nstd_traj::Vector{Float64}: The standard deviation of the TTI trajectory. The element at index l is the standard deviation of the trajectories at discretized time l.\nt_idx::Vector{Int}: The time indices used to compute the mean and standard deviation.\nautocorr::Vector{Float64}: The average TTI autocorrelation. The element at index l is the average autocorrelation of the trajectories at discretized time difference l.\nerr_autocorr::Vector{Float64}: The error associated to the TTI autocorrelation. The element at index l is error of the average autocorrelation of the trajectories at discretized time difference l.\nl_idx::Vector{Int}: The lag indices used to compute the autocorrelation.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.compute_stats_TTI-Tuple{Vector{Matrix{Float64}}, Int64}","page":"Home","title":"GaussianExpansionCavityMethod.compute_stats_TTI","text":"compute_stats_TTI(sim, teq; time_indices=nothing, lag_indices=nothing)\n\nCompute the mean, standard deviation and average autocorrelation of the trajectories in the ensemble solution object in the stationary phase, i.e. after the transient time teq. It assumes that after the transient time, the trajectories are stationary, therefore the autocorrelation is time tranlational invariant (TTI), i.e. it only depends on the time differences C(t,t') = C(t-t').\n\nArguments\n\nsim::Vector{Matrix{Float64}}: The ensemble solution object. Each element is a matrix where each column corresponds to a time point.\nteq::Int: The transient time.\n\nKeyword Arguments\n\ntime_indices::Union{Nothing, AbstractVector{Int}}: The time indices to compute the mean and standard deviation. If nothing, all time indices are used.\nlag_indices::Union{Nothing, AbstractVector{Int}}: The lag indices to compute the autocorrelation. If nothing, all lag indices are used.\n\nReturns\n\nmean_traj::Vector{Float64}: The mean TTI trajectory. The element at index l is the mean of the trajectories over nodes and ensemble realizations at discretized time l.\nstd_traj::Vector{Float64}: The standard deviation of the TTI trajectory. The element at index l is the standard deviation of the trajectories over nodes and ensemble realizations at discretized time l.\nt_idx::Vector{Int}: The time indices used to compute the mean and standard deviation.\nautocorr::Vector{Float64}: The average TTI autocorrelation. The element at index l is the average autocorrelation of the trajectories over nodes and ensemble realizations at discretized time difference l.\nerr_autocorr::Vector{Float64}: The error associated to the TTI autocorrelation. The element at index l is error of the average autocorrelation of the trajectories over nodes and ensemble realizations at discretized time difference l.\nl_idx::Vector{Int}: The lag indices used to compute the autocorrelation.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.integrate_2spin_RRG-Tuple{Int64, Float64, Float64, Int64, Float64}","page":"Home","title":"GaussianExpansionCavityMethod.integrate_2spin_RRG","text":"integrate_2spin_RRG(K, J, D, Nmax, tmax; backup=false, backupfile=\"backup_matrices.jld2\", backupevery=1000)\n\nIntegrate the disorder averaged cavity equations for a 2-spin model on a random regular graph with bimodal interactions.\n\nSrguments\n\nK::Int: The average number of neighbors.\nJ::Float64: The coupling strength.\nD::Float64: The noise strength.\nNmax::Int: The maximum number of timesteps.\ntmax::Float64: The maximum time to integrate to.\n\nKeyword Arguments\n\nbackup::Bool: Whether to save a backup of the matrices every backupevery iterations. Default is false.\nbackupfile::String: The filename for the backup file. Default is \"backup_matrices.jld2\".\nbackupevery::Int: The number of iterations to save a backup every. Default is 1000.\n\nReturns\n\nC::OffsetArray: The disorder averaged autocorrelation C matrix.\nR::OffsetArray: The disorder averaged response R matrix.\nCh::OffsetArray: The disorder averaged cavity autocorrelation Ch matrix.\nRh::OffsetArray: The disorder averaged cavity response Rh matrix.\nmu::OffsetArray: The Lagrange multiplier mu array.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.run_cavity_EQ-Tuple{OUModel, Float64, Int64}","page":"Home","title":"GaussianExpansionCavityMethod.run_cavity_EQ","text":"run_cavity_EQ(model::OUModel, dt::Float64, T::Int)\n\nRun the equilibrium cavity method for the equilibrium Ornstein-Uhlenbeck model.\n\nArguments\n\nmodel::OUModel: The Ornstein-Uhlenbeck model.\ndt::Float64: The time step size.\nT::Int: The number of time steps.\n\nKeyword Arguments\n\nC0::Float64: The initial value of the cavity autocorrelation (default is 1.0).\nshowprogress::Bool: Whether to show progress bars (default is false).\n\nReturns\n\nnodes::Vector{NodeEQ}: The updated nodes after running the cavity method, containing the cavity autocorrelations and the marginal fields.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.sample_2Spin-Tuple{TwoSpinModel, Vector{Float64}, Float64, Vector{Float64}}","page":"Home","title":"GaussianExpansionCavityMethod.sample_2Spin","text":"sample_2Spin(model, x0, tmax, tsave; rng=Xoshiro(1234), dt=1e-4)\n\nSample the spherical 2-Spin model using the Euler-Maruyama solver.\n\nArguments\n\nmodel::TwoSpinModel: The spherical 2-Spin model to sample.\nx0::Vector{Float64}: The initial condition.\ntmax::Float64: The maximum time to integrate to.\ntsave::Vector{Float64}: The time points to save the trajectory at.\n\nOptional arguments\n\nrng::AbstractRNG: The random number generator to use (default: Xoshiro(1234)).\ndt::Float64: The time step size (default: 1e-4).\n\nReturns\n\ntvec::Vector{Float64}: The time points.\ntraj::Matrix{Float64}: The trajectories. Each column corresponds to a time point.\nlambda_traj::Vector{Float64}: The Lagrange multipliers at each time point.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.sample_BM-Tuple{BMModel, Vector{Float64}, Float64, Vector{Float64}}","page":"Home","title":"GaussianExpansionCavityMethod.sample_BM","text":"sample_BM(model, x0, tmax, tsave; rng=Xoshiro(1234), diverging_threshold=1e6, dt=1e-3)\n\nSample the Bouchaud-Mezard model using a split-step Euler-Maruyama solver. The local part is solved exactly, while the non-local part is solved using the Euler-Maruyama method.\n\nArguments\n\nmodel::BMModel: The Bouchaud-Mezard model to sample.\nx0::Vector{Float64}: The initial condition.\ntmax::Float64: The maximum time to integrate to.\ntsave::Vector{Float64}: The time points to save the trajectory at.\n\nOptional arguments\n\nrng::AbstractRNG: The random number generator to use (default: Xoshiro(1234)).\ndt::Float64: The time step size (default: 1e-3).\n\nReturns\n\nt_vals::Vector{Float64}: The time points.\ntrajectories::Matrix{Float64}: The trajectories. Each column corresponds to a time point.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.sample_OU-Tuple{OUModel, Vector{Float64}, Float64, Vector{Float64}}","page":"Home","title":"GaussianExpansionCavityMethod.sample_OU","text":"sample_OU(model, x0, tmax, tsave; rng=Xoshiro(1234), diverging_threshold=1e6, dt=1e-3)\n\nSample the Ornstein-Uhlenbeck model using the Euler-Maruyama solver.\n\nArguments\n\nmodel::OUModel: The Ornstein-Uhlenbeck model to sample.\nx0::Vector{Float64}: The initial condition.\ntmax::Float64: The maximum time to integrate to.\ntsave::Vector{Float64}: The time points to save the trajectory at.\n\nOptional arguments\n\nrng::AbstractRNG: The random number generator to use (default: Xoshiro(1234)).\ndiverging_threshold::Float64: The threshold for detecting diverging solutions (default: 1e6).\ndt::Float64: The time step size (default: 1e-3).\n\nReturns\n\nt_vals::Vector{Float64}: The time points.\ntrajectories::Matrix{Float64}: The trajectories. Each column corresponds to a time point.\nsol::RODESolution: The solution object.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.sample_ensemble_2Spin-Tuple{TwoSpinModelEnsemble, Float64, Float64, Float64, Vector{Float64}, Int64}","page":"Home","title":"GaussianExpansionCavityMethod.sample_ensemble_2Spin","text":"sample_ensemble_2Spin(model_ensemble, x0_min, x0_max, tmax, tsave, nsample; rng=Xoshiro(1234), showprogress=false, dt=1e-4)\n\nSample an ensemble of spherical 2-Spin models using solvers from DifferentialEquations.jl.\n\nArguments\n\nmodel_ensemble::TwoSpinModelEnsemble: The ensemble of Phi^4 models to sample.\nx0_min::Float64: The minimum initial condition.\nx0_max::Float64: The maximum initial condition.\ntmax::Float64: The maximum time to integrate to.\ntsave::Vector{Float64}: The time points to save the trajectory at.\nnsample::Int: The number of samples to generate.\n\nOptional arguments\n\nrng::AbstractRNG: The random number generator to use (default: Xoshiro(1234)).\nshowprogress::Bool: Whether to show a progress bar (default: false).\ndt::Float64: The time step size (default: 1e-4).\n\nReturns\n\ntvals_alls::Vector{Vector{Float64}}: The time points for each sample.\ntraj_alls::Vector{Matrix{Float64}}: The trajectories for each sample. Each column corresponds to a time point.\nlambda_traj_alls::Vector{Vector{Float64}}: The Lagrange multipliers for each sample.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.sample_ensemble_BM-Tuple{BMModelEnsemble, Float64, Float64, Float64, Vector{Float64}, Int64}","page":"Home","title":"GaussianExpansionCavityMethod.sample_ensemble_BM","text":"sample_ensemble_BM(model_ensemble, x0_min, x0_max, tmax, tsave, nsample; rng=Xoshiro(1234), diverging_threshold=1e6, showprogress=false, dt=1e-3)\n\nSample an ensemble of Bouchaud-Mezard models using solvers from DifferentialEquations.jl.\n\nArguments\n\nmodel_ensemble::BMModelEnsemble: The ensemble of Phi^4 models to sample.\nx0_min::Float64: The minimum initial condition.\nx0_max::Float64: The maximum initial condition.\ntmax::Float64: The maximum time to integrate to.\ntsave::Vector{Float64}: The time points to save the trajectory at.\nnsample::Int: The number of samples to generate.\n\nOptional arguments\n\nrng::AbstractRNG: The random number generator to use (default: Xoshiro(1234)).\ndiverging_threshold::Float64: The threshold for detecting diverging solutions (default: 1e6).\nshowprogress::Bool: Whether to show a progress bar (default: false).\ndt::Float64: The time step size (default: 1e-3).\n\nReturns\n\ntvals_alls::Vector{Vector{Float64}}: The time points for each sample.\ntraj_alls::Vector{Matrix{Float64}}: The trajectories for each sample. Each column corresponds to a time point.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.sample_ensemble_OU-Tuple{OUModelEnsemble, Float64, Vector{Float64}, Int64}","page":"Home","title":"GaussianExpansionCavityMethod.sample_ensemble_OU","text":"sample_ensemble_OU(model_ensemble, tmax, tsave, nsample; rng=Xoshiro(1234), diverging_threshold=1e6, showprogress=false, dt=1e-3)\n\nSample an ensemble of Ornstein-Uhlenbeck models using solvers from DifferentialEquations.jl.\n\nArguments\n\nmodel_ensemble::OUModelEnsemble: The ensemble of Ornstein-Uhlenbeck models to sample.\ntmax::Float64: The maximum time to integrate to.\ntsave::Vector{Float64}: The time points to save the trajectory at.\nnsample::Int: The number of samples to generate.\n\nOptional arguments\n\nrng::AbstractRNG: The random number generator to use (default: Xoshiro(1234)).\ndiverging_threshold::Float64: The threshold for detecting diverging solutions (default: 1e6).\nshowprogress::Bool: Whether to show a progress bar (default: false).\ndt::Float64: The time step size (default: 1e-3).\n\nReturns\n\ntvals_alls::Vector{Vector{Float64}}: The time points for each sample.\ntraj_alls::Vector{Matrix{Float64}}: The trajectories for each sample. Each column corresponds to a time point.\nsim::Vector{RODESolution}: The solution objects for each sample.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.sample_ensemble_phi4-Tuple{Phi4ModelEnsemble, Float64, Float64, Float64, Vector{Float64}, Int64}","page":"Home","title":"GaussianExpansionCavityMethod.sample_ensemble_phi4","text":"sample_ensemble_phi4(model_ensemble, x0_min, x0_max, tmax, tsave, nsample; rng=Xoshiro(1234), diverging_threshold=1e6, showprogress=false, dt=1e-3)\n\nSample an ensemble of Phi^4 models using solvers from DifferentialEquations.jl.\n\nArguments\n\nmodel_ensemble::Phi4ModelEnsemble: The ensemble of Phi^4 models to sample.\nx0_min::Float64: The minimum initial condition.\nx0_max::Float64: The maximum initial condition.\ntmax::Float64: The maximum time to integrate to.\ntsave::Vector{Float64}: The time points to save the trajectory at.\nnsample::Int: The number of samples to generate.\n\nOptional arguments\n\nrng::AbstractRNG: The random number generator to use (default: Xoshiro(1234)).\ndiverging_threshold::Float64: The threshold for detecting diverging solutions (default: 1e6).\nshowprogress::Bool: Whether to show a progress bar (default: false).\ndt::Float64: The time step size (default: 1e-3).\n\nReturns\n\ntvals_alls::Vector{Vector{Float64}}: The time points for each sample.\ntraj_alls::Vector{Matrix{Float64}}: The trajectories for each sample. Each column corresponds to a time point.\nsim::Vector{RODESolution}: The solution objects for each sample.\n\n\n\n\n\n","category":"method"},{"location":"#GaussianExpansionCavityMethod.sample_phi4-Tuple{Phi4Model, Vector{Float64}, Float64, Vector{Float64}}","page":"Home","title":"GaussianExpansionCavityMethod.sample_phi4","text":"sample_phi4(model, x0, tmax, tsave; rng=Xoshiro(1234), diverging_threshold=1e6, dt=1e-3)\n\nSample the Phi^4 model using the Euler-Maruyama solver.\n\nArguments\n\nmodel::Phi4Model: The Phi^4 model to sample.\nx0::Vector{Float64}: The initial condition.\ntmax::Float64: The maximum time to integrate to.\ntsave::Vector{Float64}: The time points to save the trajectory at.\n\nOptional arguments\n\nrng::AbstractRNG: The random number generator to use (default: Xoshiro(1234)).\ndiverging_threshold::Float64: The threshold for detecting diverging solutions (default: 1e6).\ndt::Float64: The time step size (default: 1e-3).\n\nReturns\n\nt_vals::Vector{Float64}: The time points.\ntrajectories::Matrix{Float64}: The trajectories. Each column corresponds to a time point.\nsol::RODESolution: The solution object.\n\n\n\n\n\n","category":"method"}]
}
